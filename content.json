{"pages":[{}],"posts":[{"title":"创建和销毁对象","date":"2121-05-21T16:00:00.000Z","path":"2121/05/22/Java/创建和销毁对象/","text":"用静态方法代替构造器优点：1、有名称： 1BigInteger.probablePrime() 相比一个类具有多个相同签名的构造器，静态方法可以选择名称来避免调用错误的构造器。 2、不必每次都调用一个新的对象","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/ytz3210/tags/Java/"}]},{"title":"Java/mount命令","date":"2021-01-30T07:48:01.787Z","path":"2021/01/30/Java/mount命令/","text":"mount命令挂载数据卷 ### 进入docker执行命令 docker exec -it nginx-test bash { “Source”: “/var/lib/docker/volumes/nginx-log-vol/_data”, “Destination”: “/var/log/nginx”, “RW”: true, “Name”: “nginx-log-vol”, “Driver”: “local”, “Type”: “volume”, “Relabel”: “z”, “Spec”: { “Type”: “volume”, “Source”: “nginx-log-vol”, “Target”: “/var/log/nginx” }, “SkipMountpointCreation”: false} docker 安装mysql docker run -d -it -p 3306:3306 –name mymysql-master -v mysql-master-vol:/etc/mysql -e MYSQL_ROOT_PASSWORD=root mysql:5.7 mysql5.7开启远程访问 mysql创建用户并授权 CREATE USER ‘slave’@’%’ IDENTIFIED BY ‘slave’; binary-log statement row mixed","tags":[]},{"title":"Java/pom文件标签解析","date":"2021-01-30T07:48:01.787Z","path":"2021/01/30/Java/pom文件标签解析/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!-- project:根标签 --&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;&lt;!-- modelVersion:指定pom.xml符合哪个版本的描述符，maven2和3只能为4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- The Basic --&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;my-project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;my-parent&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;!-- relativePath: 1.不写这个标签默认值就是../pom.xml，会从本地路径中获取parent的pom 2.指定relativePath，但值为空&lt;relativePath/&gt;，此时将始终从仓库中获取，不从本地仓库获取，常见场景就是使用springboot 3.指定relativePath并且指定一个本地路径，将从本地路径获取parent的pom--&gt; &lt;relativePath&gt;../my-parent&lt;/relativePath&gt; &lt;/parent&gt;&lt;!-- 子模块列表 --&gt; &lt;modules&gt; &lt;module&gt;my-project&lt;/module&gt; &lt;module&gt;another-project&lt;/module&gt; &lt;module&gt;third-project/pom-example.xml&lt;/module&gt; &lt;/modules&gt;&lt;!-- properties:用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用$&#123;属性名&#125;的方式引用该属性，这种做法的最大意义在于消除重复和统一管理 1.内置属性：两个常用内置属性$&#123;basedir&#125;表示项目根目录；$&#123;version&#125;表示项目版本 2.pom属性:用户可以使用该类属性引用POM文件中对应元素的值。如$&#123;project.artifactId&#125;就对应了&lt;project&gt;&lt;artifactId&gt;元素的值 3.自定义属性：具有继承性 4.settings属性：用户使用以settings.开头的属性引用settings.xml文件的xml元素的值 5.Java系统属性：所有Java系统属性都可以用Maven属性引用，如$&#123;user.home&#125;指向了用户目录 6.环境变量属性：所有环境变量属性都可以使用env.开头的Maven属性引用，如$&#123;env.JAVA_HOME&#125;指代了JAVA_HOME环境变量的值--&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;!-- dependencyManagement:表示依赖jar包的声明，在项目中的dependencyManagement下声明了依赖，maven不会加载该依赖，主要是为了同意管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginMangement--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-embedder&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;!-- type对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar， type类型包括jar,war,pom--&gt; &lt;type&gt;jar&lt;/type&gt;&lt;!-- scope分为五类： compile:默认，表示被依赖项目需要参加当前项目的编译，还有后续的测试，运行周期也参与其中 test:该依赖只在测试时有用，在编译和运行时不会被用到 runtime:表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与，例如JDBC驱动，适用运行和测试阶段 provided:这个scope假定对应的依赖会由运行这个应用的JDK或者容器来提供，打包的时候可以不用包进去，别的设施会提供，事实上该依赖理论上可以参与编译，测试，运行等周期，相当于compile，但是打包阶段做了exclude操作 system:从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径 import:只在dependencyManagement元素下才有效果，作用是将目标POM中的dependencyMangement配置导入并合并到当前的POM的dependencyManagement中--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;!-- optional:其他项目依赖此项目也不会进行传递，只能本项目使用 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt;&lt;/dependencyManagement&gt; &lt;build&gt;&lt;!-- defaultGoal:执行build任务时，如果没有指定目标，将使用的默认值，如：在命令行中执行mvn，则相当于执行mvn install --&gt; &lt;defaultGoal&gt;install&lt;/defaultGoal&gt;&lt;!-- directory:build目标文件的存放目录，默认在$&#123;basedir/target&#125;目录 --&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt;&lt;!-- filnalName:build目标文件的文件名，默认情况下为$&#123;artifactId&#125;-$&#123;version&#125; --&gt; &lt;finalName&gt;$&#123;artifactId&#125;-$&#123;version&#125;&lt;/finalName&gt;&lt;!-- 定义*.properties文件，定义在filter的文件中的\"name=value\"值对会在build时替换代码中的$&#123;name&#125;值应用到resources中 --&gt; &lt;filters&gt; &lt;filter&gt;filters/filter1.properties&lt;/filter&gt; &lt;/filters&gt;&lt;!-- 资源的配置。资源文件通常不是代码，不需要编译 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;META-INF/plexus&lt;/targetPath&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/plexus&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;configuration.xml&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; ... &lt;/testResources&gt; ...&lt;/build&gt; &lt;/project&gt;","tags":[]},{"title":"mysql/explain含义","date":"2021-01-30T07:48:01.787Z","path":"2021/01/30/mysql/explain含义/","text":"https://www.jianshu.com/p/8fab76bbf448","tags":[]},{"title":"Java/MVCC","date":"2021-01-30T07:48:01.771Z","path":"2021/01/30/Java/MVCC/","text":"MVCCMVCC(Mutil-Version Concurrency Control) 多版本并发控制 在数据库管理系统中实现对数据库的并发访问 InnoDB中就是指在读已提交和可重复读这两种隔离级别下的事物对select操作会访问版本链中的记录过程 版本链在InnoDB引擎表中，有两个必要的隐藏列 trx_id存储对记录修改的时候的事物id roll_pointerroll_pointer就是一个指针，每当对记录有修改的时候，会把老版本写入undo日志中，而roll_pointer记录的就是上一个记录版本的位置（插入操作的undo日志没有这个属性，因为它没有老版本） ReadViewReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事物，也就是begin了还未提交的事物．通过这个列表来判断记录的某个版本对当前事物是否可见．","tags":[]},{"title":"Java/Slf4j注解中的topic属性","date":"2021-01-30T07:48:01.771Z","path":"2021/01/30/Java/Slf4j注解中的topic属性/","text":"Slf4j注解中的topic属性","tags":[]},{"title":"Java/jps查看所有Java进程","date":"2021-01-30T07:48:01.771Z","path":"2021/01/30/Java/jps查看所有Java进程/","text":"jps查看所有Java进程 jstack 查看某个java进程所有线程状态 栈由多个栈帧组成，每个方法是一个栈帧，当方法执行完毕会释放栈帧","tags":[]},{"title":"Java/docker","date":"2021-01-30T07:48:01.771Z","path":"2021/01/30/Java/docker/","text":"启动与停止12345678910# 启动systemctl start docker# 停止systemctl stop docker# 重启systemctl restart docker# 查看docker状态systemctl status docker# 开机启动systemctl enable docker 镜像相关命令12345678910# 查看镜像docker images# 搜索镜像docker search images# 拉取镜像docker pull 镜像名称# 删除镜像docker rmi 镜像ID # 删除所有镜像docker rmi docker images -q 修改映射端口1234567891011121314151617# 获取容器ID docker ps -a# 进入容器目录cd /var/lib/docker/containers/容器Id#停止容器docker stop 容器Id#停止docker服务systemctl stop docker#进入文件夹修改hostconfig.json\"PortBindings\":&#123;&#125;增加一个映射, 这样写:\"PortBindings\":&#123;\"3306/tcp\":[&#123;\"HostIp\":\"\",\"HostPort\":\"3307\"&#125;]&#125;前一个数字是容器端口, 后一个是宿主机端口. 而修改现有端口映射更简单, 把端口号改掉就行.#启动docker服务#启动容器","tags":[]},{"title":"Java/maven增量并行编译","date":"2021-01-30T07:48:01.771Z","path":"2021/01/30/Java/maven增量并行编译/","text":"takari-lifecycle-plugin背景随着不断的迭代，工程代码量、mapper、lombok等processor生命周期内自动生成实现类的部分越来越多，导致每一次项目打包过长的耗时都是痛点。基于增量编译以及并行编译的需求尤为重要 Takari Lifecycle简介Maven 创始人Jason Van Zyl于2013年发起了一个新的插件项目，针对原maven默认集成的maven-compiler-plugin插件提供了增量编译的新插件。该项目最后的维护时间同maven-compiler-plugin。 增量编译的好处主要体现在开发阶段，因为大多数情况只会修改部分类。但目前修改部分类导致整个项目要重新编译、打包，这个过程太耗时。增量编译解决的只是某个模块需要重新编译、打包，这样在时间成本上就节省了非常之多。而我们有时候不知道类有没有改动打包时，耗费的时间更是无意义的。因此，当增量编译时，所有类均没变更，打包的速度是几十秒级的。在开发阶段的编译时间成本降低很多。项目模块越多，编译速度提升越明显 使用方式删除lombok、mapstruct processor生命周期插件，如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;plugin&gt; &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;defaultOutputDirectory&gt;$&#123;project.build.directory&#125;/generated-sources&lt;/defaultOutputDirectory&gt;z &lt;processors&gt; &lt;processor&gt;lombok.launch.AnnotationProcessorHider$AnnotationProcessor&lt;/processor&gt; &lt;processor&gt;org.mapstruct.ap.MappingProcessor&lt;/processor&gt; &lt;/processors&gt; &lt;options&gt; &lt;mapstruct.suppressGeneratorTimestamp&gt;true&lt;/mapstruct.suppressGeneratorTimestamp&gt; &lt;mapstruct.defaultComponentModel&gt;spring&lt;/mapstruct.defaultComponentModel&gt; &lt;mapstruct.unmappedTargetPolicy&gt;IGNORE&lt;/mapstruct.unmappedTargetPolicy&gt; &lt;/options&gt; &lt;/configuration&gt;&lt;/plugin&gt; 禁用 maven-compiler-plugin123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 增加 skip = true --&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;!-- skipMain = true --&gt; &lt;skipMain&gt;true&lt;/skipMain&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;compilerVersion&gt;$&#123;jdk.version&#125;&lt;/compilerVersion&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/plugin&gt; 添加 takari-lifecycle-plugin 插件12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;io.takari.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;takari-lifecycle-plugin&lt;/artifactId&gt; &lt;version&gt;1.13.10&lt;/version&gt; &lt;extensions&gt;true&lt;/extensions&gt; &lt;configuration&gt; &lt;parameters&gt;true&lt;/parameters&gt; &lt;proc&gt;proc&lt;/proc&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;annotationProcessorOptions&gt; &lt;mapstruct.suppressGeneratorTimestamp&gt;true&lt;/mapstruct.suppressGeneratorTimestamp&gt; &lt;mapstruct.defaultComponentModel&gt;spring&lt;/mapstruct.defaultComponentModel&gt; &lt;mapstruct.unmappedTargetPolicy&gt;IGNORE&lt;/mapstruct.unmappedTargetPolicy&gt; &lt;/annotationProcessorOptions&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;jar&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 额外需要添加的依赖，主要是 mapstruct-processor12345678910&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt;&lt;/dependency&gt; 修改 package 类型12# 将需要打包为jar的package类型修改为takari-jar&lt;packaging&gt;takari-jar&lt;/packaging&gt; 并行编译支持取决于项目，如果包含子模块依赖，需要有一个完整的依赖图。 maven 新版本增项maven 从3.2.x以后的版本支持在项目根目录下创建名为.mvn的文件夹，支持定制当前maven项目的相关配置，包含以下2个文件的配置: jvm.config12# jvm 参数配置-Xmx2048m -Xms1024m -XX:MaxPermSize=512m -Djava.awt.headless=true maven.config12# mvn 执行命令行追加其它固定参数，此处为1个核心2个线程并行编译，线程数：n核*2-T 2C 实测12全量编译性能提升 &gt; 20%增量编译取决于修改的哪个模块，模块包含的lombok&#x2F;mapper类量级不同，增量编译的速度不同，无任何修改的编译，性能提升 &gt; 80%，部分修改的编译性能提升 &gt; 60%","tags":[]},{"title":"docker-mysql","date":"2021-01-30T07:48:01.740Z","path":"2021/01/30/docker-mysql/","text":"docker run -d –name mysql -e MYSQL_ROOT_PASSWORD=111111 -p 3306:3306 mysql:5.7","tags":[]},{"title":"ThreadPoolExecutor四种拒绝策略","date":"2020-10-21T16:00:00.000Z","path":"2020/10/22/Java/ThreadPoolExecutor四种拒绝策略/","text":"ThreadPoolExecutor４种拒绝策略 discard 丢弃，抛弃 AbortPolicy(默认策略) 丢弃任务并抛出RejectedExecutionException异常 DiscardPolicy 丢弃任务，但是不抛出异常 DiscardOldestPolicy 丢弃队列最前面的任务，然后重新提交被拒绝的任务 CallerRunsPolicy 由调用线程（提交任务的线程）处理该任务","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/ytz3210/tags/Java/"}]},{"title":"毕业设计小知识点","date":"2020-01-31T13:47:00.000Z","path":"2020/01/31/毕业设计/小知识点/","text":"@Autowired和@Resource注解的区别1.@Autowired是由spring提供 ​ @Resource是由J2EE提供 2.@Autowired采取的策略是按照类型进行注入，如果一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情形，这个时候就会配合着@Qualifier使用 12345public class UserService &#123; @Autowired @Qualifier(name=\"userDao1\") private UserDao userDao; &#125; ​ @Resource默认是按照名称进行注入 ​ ①如果同时指定name和type，则从spring上下文中寻找唯一的bean进行装配 ​ ②如果指定type，则从上下文中查找类似匹配的唯一bean进行装配，找不到或者找到多个都会抛出异常 ​ ③如果指定了name，则从上下文中查找名称匹配的bean进行装配，找不到则抛出异常 @RequestBody注解@Request接收的是一个json格式的字符串，一定是一个字符串，通常用来处理content-type不是默认的application/x-www-form-urlcoded,比如application/json等，一般情况下来说常用来处理application/json类型。 PO、POJO、BO、VO PO：persistent object 持久对象 对应数据库中的entity，可以简单的认为一个PO对应数据库中的一条记录 PO中不应该包含任何对数据库的操作 POJO：plain ordinary java object 无规则简单Java对象 POJO进行持久化操作之后==&gt;PO POJO用作表示层==&gt;VO BO：business object 业务对象 业务对象主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象 关于BO主要有三种概念 1.只包含业务对象的属性 2.只包含业务方法 3.两者都包含 VO：view object/value object 表现层对象 主要对应页面显示的数据队形 可以和表对应，也可以不，这根据业务的需要 Centos7开放及查看端口12345678firewall-cmd --zone=public --add-port=80/tcp --permanent #开放80端口firewall-cmd --zone=public --remove-port=80/tcp --permanent #关闭80端口firewall-cmd --reload #配置立即生效firewall-cmd --zone=public --list-ports #查看防火墙所有开放的端口#检查端口被那个进程占用netstat -lnpt | grep 80#查看进程详细信息ps 80 Centos7安装nginx123456789101112131415161718192021#linux编译器yum -y install gcc#pcre,pcre-devel正则表达式库yum -y install pcre pcre-devel#zlib解压和压缩yum -y install zlib zlib-devel#openssl：web安全通信的基石yum -y install openssl openssl-devel#下载nginx安装包wget http://nginx.org/download/nginx-1.9.9.tar.gz #解压缩到/usr/local/mynginxtar -zxvf nginx-1.9.9.tar.gz #切换到/usr/local/mynginx/nginx-1.9.9./configuremakemake install#启动nginx将目录切换到/usr/local/nginx/sbin./nginx#查看是否成功ps -ef | grep nginx CommandLineRunner开发中可能会需要实现下项目启动后执行的功能，springboot提供的一个简单实现方案就是实现CommandLineRunner接口，实现的功能代码放在实现的run方法中。","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"git项目初始化","date":"2020-01-15T13:47:00.000Z","path":"2020/01/15/毕业设计/git项目初始化/","text":"git项目初始化1.新建READ.md 1touch READ.md 2.向.gitinore中添加忽略的文件 123456789101112131415161718### IntelliJ IDEA ###.idea//idea/.mvn/mvn/*.iws*.iml*.ipr### temp file ###*.log*.cache*.diff*.patch*.tmp### system ignore ###.DS_StoreThumbs.db 123456789101112131415161718192021222324252627# 初始化git init# 添加git add .# 添加到本地仓库git commit -m \"first commit\"# 往远程推送git remote add origin git地址# 查看所在分支git branch# 推送（会报错）git push -u origin master# 拉取项目git pull# 推送git push -u origin master# 强制推送git push -u -f origin master# 查看所在分支git branch# 分支开发，主干发布# 新建分支git checkout -b v1.0 origin/master# 检查所在分支git branch# 推送分支git push origin HEAD -u","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"用户模块","date":"2020-01-15T13:47:00.000Z","path":"2020/01/15/毕业设计/用户模块/","text":"横向越权和纵向越权安全漏洞 横向越权攻击者尝试访问与他拥有相同权限的用户的资源 纵向越权攻击者尝试访问高级别用户的资源 高复用服务响应对象的设计思想及封装","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"mysql忘记密码","date":"2020-01-12T16:00:00.000Z","path":"2020/01/13/mysql/msql重置密码的副本/","text":"Mysql错误You must reset your password using ALTER USER statement before executing this statement （1）MySQL版本5.7.6版本（以前）用户可以使用如下命令： 1mysql&gt; SET PASSWORD &#x3D; PASSWORD(&#39;l!vWT#mL93&#39;); （2）MySQL版本5.7.6版本（开始后）的用户可以使用如下命令： 1mysql&gt; ALTER USER USER() IDENTIFIED BY &#39;l!vWT#mL93&#39;;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"如何保证线程安全","date":"2019-12-22T13:47:00.000Z","path":"2019/12/22/毕业设计/线程安全/","text":"如何保证线程安全线程安全 一般说来，确保线程安全的方法有这几个：竞争与原子操作、同步与锁、可重入、过度优化。 竞争与原子操作 多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作***作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。 因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于比较简单的场合，在复杂的情况下就要选用其他的方法了。 同步与锁 为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。 同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。 二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，要使用多元信号量(简称信号量)。 可重入 一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。 过度优化 在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安全，因此，我们可能对代码进行过度的优化以确保线程安全。 我们可以使用volatile关键字试图阻止过度优化，它可以做两件事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写回；第二，阻止编译器调整操作volatile变量的指令顺序。 在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困难，通常的解决办法是调用CPU提供的一条常被称作barrier的指令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"Redis单机集群配置","date":"2019-12-11T16:00:00.000Z","path":"2019/12/12/redis/单机集群配置/","text":"Redis单机集群配置简介所谓Redis集群就是一个可以在多个Redis节点之间进行数据共享的设施。 因此Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，不仅会降低Redis集群的性能，而且还会导致不可预测的错误。 好处： 将数据自动切分到多个节点的能力 当其中一个节点失效时，仍然可以继续处理命令请求 搭建1.在/usr/local下新建redis-cluster目录并在redis-cluster下新建6380-6385共6个文件夹，这6个文件夹代表创建redis集群的6个节点 12341.cd &#x2F;usr&#x2F;local2.mkdir &#x2F;usr&#x2F;local&#x2F;redis-cluster3.cd redis-cluster4.mkdir 6380 6381 6382 6383 6384 6395 2.将已有的/usr/local/redis下的redis.conf拷贝到新创建的6380-6385目录中 修改这6个目录下的redis.conf 1234567891011121314#绑定端口port 6380#指定数据存放路径dir /usr/local/redis-cluster/6380#启动集群模式cluster-enable true#指定集群节点配置文件cluster-config-file nodes-6380.conf#后台启动daemonize yes#指定集群节点超时时间cluster-node-timeout 5000#指定持久化方式appendonly yes 3.将6380的redis.conf改完后再拷贝到剩下的5个目录中，然后只要全局替换redis.conf中的6380为相应的节点即可 4.安装ruby 121.yum install ruby2.yum install rubygems 安装rvm 因为CentOS7 yum库中ruby的版本支持到 2.0.0，可gem 安装redis需要最低是2.2.2，采用rvm来更新ruby 12345678910111.gpg --keyserver hkp:&#x2F;&#x2F;keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB2.curl -sSL https:&#x2F;&#x2F;get.rvm.io | bash -s stable3.find &#x2F; -name rvm -print4.source &#x2F;usr&#x2F;local&#x2F;rvm&#x2F;scripts&#x2F;rvm5.rvm list known6.rvm install 2.4.17.rvm use 2.4.18. rvm use 2.4.1 --default9.rvm remove 2.3.410.ruby --version11.gem install redis 5.启动redis实例 121.cd &#x2F;usr&#x2F;local&#x2F;redis-cluster2.for((i&#x3D;0;i&lt;&#x3D;5;i++)); do &#x2F;usr&#x2F;local&#x2F;redis&#x2F;src&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;638$i&#x2F;redis.conf; done 6.查看redis是否运行成功 1ps -aux|grep redis 7.创建集群 1redis-cli --cluster create 172.30.0.2:6380 172.30.0.2:6381 172.30.0.2:6382 172.30.0.2:6383 172.30.0.2:6384 172.30.0.2:6385 --cluster-replicas 1 -a &#39;redis密码&#39;","tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/ytz3210/tags/Redis/"}]},{"title":"jmeter聚合报告参数","date":"2019-12-09T16:00:00.000Z","path":"2019/12/10/mysql/jmeter参数/","text":"Label：请求名称 #Sample: 总线程数=线程数*循环次数 平均值：单个请求的平均响应时间=总响应时间/发送到服务器的总请求数 设n是第n个到达的(n&gt;=1),响应时间为nt 总响应时间=$$ \\sum_{i=1}^n it $$ 中位数：50%用户的响应时间 90%：90%用户的响应时间 95%：95%用户的响应时间 99%：99%用户的响应时间 最小值：最小的响应时间 最大值：最大的响应时间 异常：错误率 吞吐量：默认情况下每秒完成的请求数=总请求数/总时间 接收：每秒从服务端接收到的数据量 发送：每秒从客户端发送的请求的数量","tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://github.com/ytz3210/tags/jmeter/"}]},{"title":"中断和异常","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/中断和异常/","text":"中断和异常中断机制的诞生为了解决程序只能串行执行，效率低的问题，实现了多道程序并发执行 中断的本质：意味着需要操作系统的介入，开展管理工作 中断的概念和作用1.中断发生时，CPU立即进入核心态 2.中断发生后，当前进程暂停运行，由操作系统对中断进行处理 3.对于不同的中断信号，进行不同的处理 用户态到核心态是通过中断实现的，并且中断时唯一途径 核心态到用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。 中断的分类​内中断（异常）信号来源：CPU内部，与当前执行的指令有关 自愿中断（指令中断） 强迫中断 硬件故障（缺页） 软件中断（整数除零） 外中断（中断）信号来源：CPU外部，与当前执行的指令无关 外设请求 人工干预 外中断的处理过程1.每执行完一条指令，CPU都要检查当前是否有外部中断信号 2.如果有，则保存被中断进程的CPU环境 3.转入相应的中断处理程序 4.恢复原进程CPU环境并推出中断，返回原进程继续执行","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"系统调用","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/系统调用/","text":"系统调用什么是系统调用，有什么作用系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为是一种可供应用程序调用的特殊函数，应用程序可以发出系统调用获得操作系统的服务。 凡是与资源有关的操作都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 系统调用和库函数的区别系统调用背后的过程","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"centos7端口开放","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/Linux开放端口/","text":"Linux CentOS 7开放端口12sudo firewall-cmd --zone=public --add-port=6789/tcp --permanentsudo firewall-cmd --reload","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/ytz3210/tags/Linux/"}]},{"title":"mysql忘记密码","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/msql重置密码/","text":"MySQL重置密码1.打开my.cnf文件 12#在[mysqld]的段中加入skip-grant-tables 2.重启mysqld 1service mysqld restart 3.输入 12mysql -u root -p#然后直接敲回车 4.修改密码（5.7之前） 1234use mysqlupdate user set password=password('new password') where user='root'flush privilegesquit 修改密码（5.7之后） 1234use mysqlupdate user set authentication_string=password('新密码') where user='root'flush privilegesquit 5.删除在my.cnf中加入的语句 6.重启mysqld Mysql开启远程登录1234mysql -u root –pmysql&gt;use mysql;mysql&gt;update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;mysql&gt;select host, user from user; Mysql授权例如，你想root使用123456从任何主机连接到mysql服务器。 1mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; 如果你想允许用户jack从ip为10.10.50.127的主机连接到mysql服务器，并使用654321作为密码 12mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;jack&#39;@’10.10.50.127’ IDENTIFIED BY &#39;654321&#39; WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"mysql的卸载和安装","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/卸载MySQL/","text":"Linux CentOS完全卸载MySQL一、yum方式安装，执行以下命令 123yum remove mysql mysql-server mysql-libs compat-mysql57rm -rf &#x2F;var&#x2F;lib&#x2F;mysqlrm -rf &#x2F;etc&#x2F;my.cnf 二、判断是否卸载干净 123rpm -qa|grep mysql卸载干净：没有任何输出未卸载干净：继续yum remove xxx","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"Java泛型","date":"2019-11-26T16:00:00.000Z","path":"2019/11/27/Java/Java泛型/","text":"Java泛型什么是泛型？泛型的意思就是广泛的类型，类，接口，方法和变量都可以应用于非常广泛的类型。 泛型怎么用例子： 定义: 12345678910111213141516171819202122232425262728293031323334/** * 单泛型 */public class Study&lt;T&gt;&#123; T student; T teacher; public Study(T student,T teacher)&#123; this.student = student; this.teacher = teacher; &#125; public T getStudent()&#123; return student; &#125; public T getTeacher()&#123; return teacher; &#125;&#125;/** * 多泛型 */public class Teach&lt;U,V&gt;&#123; U student; V teacher; public Teach(U student,V teacher)&#123; this.student = student; this.teacher = teacher; &#125; public U getStudent()&#123; return student; &#125; public V getTeacher()&#123; return teacher; &#125;&#125; 使用 12Study&lt;Integer&gt; study = new Study&lt;&gt;(1,100);Teach&lt;String,Integer&gt; teach = new Teach&lt;&gt;(\"张三\",100); 泛型有哪些好处将接口的概念进一步延伸，使得代码和它们操作的数据类型不再需要绑在一起，一套代码可以适用于多种数据类型，实现更灵活的代码复用，提高代码的可读性和安全性。 1.更好的安全性 2.更好的可读性 与Object相比，Object只有在程序运行时才会提示ClassCastException异常，但是泛型会在编译时就会报错","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/ytz3210/tags/Java/"}]},{"title":"操作系统的发展与分类","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的发展/","text":"操作系统的发展与分类手工操作阶段-&gt;单道批处理系统-&gt;多道批处理系统-&gt;分时操作系统-&gt; 实时处理系统 操作系统的运行机制和体系结构指令是CPU能识别和执行的最基本的命令 特权指令（不允许用户程序使用） 非特权指令 CPU如何判断当前是否可以执行特权指令？ 答：将CPU分为用户态（目态）和核心态（管态），用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态 ​ 将程序分为内核程序和应用程序，操作系统的内核程序是系统的管理者，既可执行特权指令，也可执行非特权指令，运行在核心态 ​ 应用程序只能执行非特权指令，运行在用户态 内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序 时钟管理 实现计时功能 中断处理 实现中断机制 原语 是一种特殊的程序 位于操作系统最底层，最接近硬件 具有原子性 运行时间短，调用频繁 对系统资源进行管理 进程管理 存储器管理 设备管理 大内核和微内核 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：性能高 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁切换核心态和用户态，性能低","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统的概念、功能和目标","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的概念/","text":"操作系统的概念、功能和目标操作系统的概念控制和管理计算机系统的硬件和软件资源，进行计算机的资源的和工作调度，是计算机中最基本的系统软件 操作系统的功能和目标需要提供哪些功能（作为系统资源的管理者）1.文件管理（找到QQ可执行文件的位置） 2.内存管理（QQ运行需要把数据装入内存） 3.处理机管理（QQ运行指令需要处理机调度） 4.设备管理（打开摄像头和朋友视频聊天） 需要实现什么功能（作为用户与计算机硬件之间的接口）1.命令接口：允许用户直接使用 联机命令接口：用户说一句，系统做一句 脱机命令接口：用户说一句，系统做一堆 2.程序接口：允许用户通过程序简介使用 由一组系统调用命令组成，程序接口=系统调用 3.GUI图形用户接口 需要在纯硬件的基础上实现什么功能（作为最接近硬件的层次）对硬件机器进行拓展，组合，使用户无需关心这些东西在底层是怎么组织起来的，让硬件变得更加强大 操作系统的特征并发宏观上在同一时间发生，微观上交替发生 共享 互斥共享 在一个时间段内只允许一个进程访问该资源（视频聊天时，摄像头只允许被一个进程使用） 同时共享 允许一个时间段内由多个进程“同时”（宏观上同时）对它们进行访问（使用不同的软件同时发送同一个文件） 并发性和共享性互为存在条件 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的的意义 如果失去共享性，那么多个程序就不能同时访问系统资源，就无法实现并发访问资源，也就是无法并发 虚拟把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。 例如：一个单核CPU运行六个程序，一个单核CPU是真实存在的，但是用户却感觉好像有六个CPU在同时为自己服务 空分复用技术 时分复用技术 异步多道程序环境下，多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的（有可能遇到阻塞，执行的顺序不一样），而走走停停，以不可预知的速度往前推进。 例如：1，2，3，4总共四个指令 第一种方案：1，2，3，4 第二种方案：1，2（阻塞，等到资源和CPU就位之后才能执行），3，4 第三种方案：4，2，3（遇到阻塞），1 ··· 只有系统拥有并发性，才可能导致异步性","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"秒杀系统基本架构","date":"2019-11-23T14:53:00.000Z","path":"2019/11/23/毕业设计/秒杀系统基本架构/","text":"系统基本架构 基本架构","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"秒杀业务场景分析","date":"2019-11-23T13:47:00.000Z","path":"2019/11/23/毕业设计/秒杀业务场景分析/","text":"秒杀业务场景分析秒杀/抢购业务场景 商品秒杀 商品抢购 群红包 抢优惠券 抽奖 秒杀/抢购业务特点 秒杀商品价格低廉 抢购商品大部分质量很好 大幅推广、广为人知 瞬时售空 定时上架 持续时间短 瞬时并发量高 秒杀/抢购技术特点 读多写少（买得人多，商品数量少）（缓存） 高并发（缓存，限流（重点），负载均衡，异步，队列） 资源冲突（乐观锁，悲观锁，分布式锁，其它原子操作）","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"二叉树的遍历","date":"2019-11-21T09:43:00.000Z","path":"2019/11/21/LeetCode/二叉树遍历/","text":"二叉树的遍历 先序遍历中序遍历后序遍历","tags":[{"name":"递归","slug":"递归","permalink":"https://github.com/ytz3210/tags/%E9%80%92%E5%BD%92/"}]},{"title":"样例","date":"2019-11-20T16:00:00.000Z","path":"2019/11/21/样例/样例/","text":"样例页面 Hello World","tags":[{"name":"样例","slug":"样例","permalink":"https://github.com/ytz3210/tags/%E6%A0%B7%E4%BE%8B/"}]},{"title":"代理模式","date":"2019-11-20T16:00:00.000Z","path":"2019/11/21/设计模式/代理模式/","text":"静态代理模式什么是代理模式首先来看代理模式的三个重要角色 Subject:抽象角色，是一个最普通的业务类型定义，可以是接口，也可以是抽象类 Proxied:具体角色，被代理角色，委托人，被代理者，是业务逻辑的具体执行者 Proxy:代理角色，代理类，在被代理类处理完毕前后做预处理和善后工作 应该怎样理解这三个角色呢？ 比如你要买房，那么买房就是这个抽象角色，而你就是具体角色，也就是被代理角色，因为你买房要找中介，而中介就是代理角色，你只需要执行买房这个动作就行了，而买房前需要干什么，买房后需要干什么都交由中介（代理角色）去完成。 代理可以在保持目标代码对象（Proxied）不动的情况下，对对象访问前后进行一些操作 什么是静态代理模式由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了,事先知道要代理的是什么。 为什么要使用静态代理模式可以在不修改目标对象的前提下扩展目标对象的功能 怎么使用静态代理模式1.创建一个抽象角色 123public interface Subject &#123; void operate();&#125; 2.创建委托人，被代理角色 123456789/** * 实现抽象角色 */public class Proxied implements Subject &#123; @Override public void operate() &#123; System.err.println(\"Proxied实现\"); &#125;&#125; 3.创建代理人 123456789101112131415/** * 实现抽象角色 */public class Proxy implements Subject &#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void operate() &#123; System.err.println(\"Proxy操作前\"); subject.operate(); System.err.println(\"Proxy操作后\"); &#125;&#125; 4.通过客户端创建并访问 12345678public class Client &#123; public static void main(String[] args) &#123; //创建被代理角色 Proxied proxied = new Proxied(); //创建代理角色 Proxy proxy = new Proxy(proxied); proxy.operate(); &#125; 从上述代码可以看出，代理角色和被代理角色都要实现抽象角色这个接口 静态代理模式有什么缺点1.代理角色和抽象角色耦合度高，就是说，如果我有一百个抽象角色，但是每个抽象角色都要使用相同的代理角色的话，必须要创建一百个代理角色，重用性不强 2.一旦接口抽象角色新增方法，目标对象与代理对象都要修改 由此引发了动态代理模式 动态代理模式什么是动态代理模式在程序运行时，运用反射机制动态创建而成，动态代理不知道要代理什么东西，只有在运行时才知道。 为什么要使用动态代理模式当然是为了改进静态代理模式。 怎么使用动态代理模式1.创建一个抽象角色 123public interface Subject &#123; void operate();&#125; 2.创建委托人，被代理角色 123456789/** * 实现抽象角色 */public class Proxied implements Subject &#123; @Override public void operate() &#123; System.err.println(\"Proxied实现\"); &#125;&#125; 3.创建动态代理 123456789101112public class DynamicProxy implements InvocationHandler &#123; private Object target; public DynamicProxy(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.err.println(\"动态代理\"); method.invoke(target,args); return null; &#125;&#125; 4.客户端访问 12345678public class Client &#123; public static void main(String[] args) &#123; Proxied proxied = new Proxied(); InvocationHandler invocationHandler = new DynamicProxy(proxied); Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(Proxied.class.getClassLoader(),Proxied.class.getInterfaces(),invocationHandler); subject.operate(); &#125;&#125; Proxy代理的缺点虽然这种方法降低了对代码的侵入性，可以在不修改源码的情况下增强方法，但是，它是基于接口实现的代理，也就是说被代理人必须要实现一个接口才能被代理，那么有什么方法可以在被代理人不实现接口的情况下实现代理呢？CGLIB代理模式应运而生 CGLIB代理模式什么是CGLIB动态代理CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。 为什么要使用CGLIB动态代理解决Proxy动态代理只能对实现了接口的类生成代理问题 怎么使用CGLIB动态代理1.创建委托人，被代理角色 12345public class CGLIBProxied &#123; public void say()&#123; System.err.println(\"你好，我是CGLIB被代理类\"); &#125;&#125; 3.创建动态代理 12345678910111213141516public class CGLIBProxy implements MethodInterceptor &#123; /** * sub：cglib生成的代理对象 * method：被代理对象方法 * objects：方法入参 * methodProxy: 代理方法 */ @Override public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"======插入前置通知======\"); Object object = methodProxy.invokeSuper(sub, objects); System.out.println(\"======插入后者通知======\"); return object; &#125;&#125; 4.客户端访问 1234567891011121314public class CGLIBClient &#123; public static void main(String[] args) &#123; // 通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); // 设置enhancer对象的父类 enhancer.setSuperclass(CGLIBProxied.class); // 设置enhancer的回调对象 enhancer.setCallback(new CGLIBProxy()); // 创建代理对象 CGLIBProxied proxied= (CGLIBProxied) enhancer.create(); // 通过代理对象调用目标方法 proxied.say(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/ytz3210/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}