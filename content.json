{"pages":[{}],"posts":[{"title":"毕业设计小知识点","date":"2020-01-31T13:47:00.000Z","path":"2020/01/31/毕业设计/小知识点/","text":"@Autowired和@Resource注解的区别1.@Autowired是由spring提供 ​ @Resource是由J2EE提供 2.@Autowired采取的策略是按照类型进行注入，如果一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情形，这个时候就会配合着@Qualifier使用 12345public class UserService &#123; @Autowired @Qualifier(name=\"userDao1\") private UserDao userDao; &#125; ​ @Resource默认是按照名称进行注入 ​ ①如果同时指定name和type，则从spring上下文中寻找唯一的bean进行装配 ​ ②如果指定type，则从上下文中查找类似匹配的唯一bean进行装配，找不到或者找到多个都会抛出异常 ​ ③如果指定了name，则从上下文中查找名称匹配的bean进行装配，找不到则抛出异常 @RequestBody注解@Request接收的是一个json格式的字符串，一定是一个字符串，通常用来处理content-type不是默认的application/x-www-form-urlcoded,比如application/json等，一般情况下来说常用来处理application/json类型。 PO、POJO、BO、VO PO：persistent object 持久对象 对应数据库中的entity，可以简单的认为一个PO对应数据库中的一条记录 PO中不应该包含任何对数据库的操作 POJO：plain ordinary java object 无规则简单Java对象 POJO进行持久化操作之后==&gt;PO POJO用作表示层==&gt;VO BO：business object 业务对象 业务对象主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象 关于BO主要有三种概念 1.只包含业务对象的属性 2.只包含业务方法 3.两者都包含 VO：view object/value object 表现层对象 主要对应页面显示的数据队形 可以和表对应，也可以不，这根据业务的需要 Centos7开放及查看端口12345678firewall-cmd --zone=public --add-port=80/tcp --permanent #开放80端口firewall-cmd --zone=public --remove-port=80/tcp --permanent #关闭80端口firewall-cmd --reload #配置立即生效firewall-cmd --zone=public --list-ports #查看防火墙所有开放的端口#检查端口被那个进程占用netstat -lnpt | grep 80#查看进程详细信息ps 80 Centos7安装nginx123456789101112131415161718192021#linux编译器yum -y install gcc#pcre,pcre-devel正则表达式库yum -y install pcre pcre-devel#zlib解压和压缩yum -y install zlib zlib-devel#openssl：web安全通信的基石yum -y install openssl openssl-devel#下载nginx安装包wget http://nginx.org/download/nginx-1.9.9.tar.gz #解压缩到/usr/local/mynginxtar -zxvf nginx-1.9.9.tar.gz #切换到/usr/local/mynginx/nginx-1.9.9./configuremakemake install#启动nginx将目录切换到/usr/local/nginx/sbin./nginx#查看是否成功ps -ef | grep nginx CommandLineRunner开发中可能会需要实现下项目启动后执行的功能，springboot提供的一个简单实现方案就是实现CommandLineRunner接口，实现的功能代码放在实现的run方法中。","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"git项目初始化","date":"2020-01-15T13:47:00.000Z","path":"2020/01/15/毕业设计/git项目初始化/","text":"git项目初始化1.新建READ.md 1touch READ.md 2.向.gitinore中添加忽略的文件 123456789101112131415161718### IntelliJ IDEA ###.idea//idea/.mvn/mvn/*.iws*.iml*.ipr### temp file ###*.log*.cache*.diff*.patch*.tmp### system ignore ###.DS_StoreThumbs.db 123456789101112131415161718192021222324252627# 初始化git init# 添加git add .# 添加到本地仓库git commit -m \"first commit\"# 往远程推送git remote add origin git地址# 查看所在分支git branch# 推送（会报错）git push -u origin master# 拉取项目git pull# 推送git push -u origin master# 强制推送git push -u -f origin master# 查看所在分支git branch# 分支开发，主干发布# 新建分支git checkout -b v1.0 origin/master# 检查所在分支git branch# 推送分支git push origin HEAD -u","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"用户模块","date":"2020-01-15T13:47:00.000Z","path":"2020/01/15/毕业设计/用户模块/","text":"横向越权和纵向越权安全漏洞 横向越权攻击者尝试访问与他拥有相同权限的用户的资源 纵向越权攻击者尝试访问高级别用户的资源 高复用服务响应对象的设计思想及封装","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"mysql忘记密码","date":"2020-01-12T16:00:00.000Z","path":"2020/01/13/mysql/msql重置密码的副本/","text":"Mysql错误You must reset your password using ALTER USER statement before executing this statement （1）MySQL版本5.7.6版本（以前）用户可以使用如下命令： 1mysql&gt; SET PASSWORD = PASSWORD(&apos;l!vWT#mL93&apos;); （2）MySQL版本5.7.6版本（开始后）的用户可以使用如下命令： 1mysql&gt; ALTER USER USER() IDENTIFIED BY &apos;l!vWT#mL93&apos;;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"如何保证线程安全","date":"2019-12-22T13:47:00.000Z","path":"2019/12/22/毕业设计/线程安全/","text":"如何保证线程安全线程安全 一般说来，确保线程安全的方法有这几个：竞争与原子操作、同步与锁、可重入、过度优化。 竞争与原子操作 多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作***作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。 因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于比较简单的场合，在复杂的情况下就要选用其他的方法了。 同步与锁 为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。 同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。 二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，要使用多元信号量(简称信号量)。 可重入 一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。 过度优化 在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安全，因此，我们可能对代码进行过度的优化以确保线程安全。 我们可以使用volatile关键字试图阻止过度优化，它可以做两件事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写回；第二，阻止编译器调整操作volatile变量的指令顺序。 在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困难，通常的解决办法是调用CPU提供的一条常被称作barrier的指令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"Redis单机集群配置","date":"2019-12-11T16:00:00.000Z","path":"2019/12/12/redis/单机集群配置/","text":"Redis单机集群配置简介所谓Redis集群就是一个可以在多个Redis节点之间进行数据共享的设施。 因此Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，不仅会降低Redis集群的性能，而且还会导致不可预测的错误。 好处： 将数据自动切分到多个节点的能力 当其中一个节点失效时，仍然可以继续处理命令请求 搭建1.在/usr/local下新建redis-cluster目录并在redis-cluster下新建6380-6385共6个文件夹，这6个文件夹代表创建redis集群的6个节点 12341.cd /usr/local2.mkdir /usr/local/redis-cluster3.cd redis-cluster4.mkdir 6380 6381 6382 6383 6384 6395 2.将已有的/usr/local/redis下的redis.conf拷贝到新创建的6380-6385目录中 修改这6个目录下的redis.conf 1234567891011121314#绑定端口port 6380#指定数据存放路径dir /usr/local/redis-cluster/6380#启动集群模式cluster-enable true#指定集群节点配置文件cluster-config-file nodes-6380.conf#后台启动daemonize yes#指定集群节点超时时间cluster-node-timeout 5000#指定持久化方式appendonly yes 3.将6380的redis.conf改完后再拷贝到剩下的5个目录中，然后只要全局替换redis.conf中的6380为相应的节点即可 4.安装ruby 121.yum install ruby2.yum install rubygems 安装rvm 因为CentOS7 yum库中ruby的版本支持到 2.0.0，可gem 安装redis需要最低是2.2.2，采用rvm来更新ruby 12345678910111.gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB2.curl -sSL https://get.rvm.io | bash -s stable3.find / -name rvm -print4.source /usr/local/rvm/scripts/rvm5.rvm list known6.rvm install 2.4.17.rvm use 2.4.18. rvm use 2.4.1 --default9.rvm remove 2.3.410.ruby --version11.gem install redis 5.启动redis实例 121.cd /usr/local/redis-cluster2.for((i=0;i&lt;=5;i++)); do /usr/local/redis/src/redis-server /usr/local/redis-cluster/638$i/redis.conf; done 6.查看redis是否运行成功 1ps -aux|grep redis 7.创建集群 1redis-cli --cluster create 172.30.0.2:6380 172.30.0.2:6381 172.30.0.2:6382 172.30.0.2:6383 172.30.0.2:6384 172.30.0.2:6385 --cluster-replicas 1 -a &apos;redis密码&apos;","tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/ytz3210/tags/Redis/"}]},{"title":"jmeter聚合报告参数","date":"2019-12-09T16:00:00.000Z","path":"2019/12/10/mysql/jmeter参数/","text":"Label：请求名称 #Sample: 总线程数=线程数*循环次数 平均值：单个请求的平均响应时间=总响应时间/发送到服务器的总请求数 设n是第n个到达的(n&gt;=1),响应时间为nt 总响应时间=$$ \\sum_{i=1}^n it $$ 中位数：50%用户的响应时间 90%：90%用户的响应时间 95%：95%用户的响应时间 99%：99%用户的响应时间 最小值：最小的响应时间 最大值：最大的响应时间 异常：错误率 吞吐量：默认情况下每秒完成的请求数=总请求数/总时间 接收：每秒从服务端接收到的数据量 发送：每秒从客户端发送的请求的数量","tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://github.com/ytz3210/tags/jmeter/"}]},{"title":"中断和异常","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/中断和异常/","text":"中断和异常中断机制的诞生为了解决程序只能串行执行，效率低的问题，实现了多道程序并发执行 中断的本质：意味着需要操作系统的介入，开展管理工作 中断的概念和作用1.中断发生时，CPU立即进入核心态 2.中断发生后，当前进程暂停运行，由操作系统对中断进行处理 3.对于不同的中断信号，进行不同的处理 用户态到核心态是通过中断实现的，并且中断时唯一途径 核心态到用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。 中断的分类​内中断（异常）信号来源：CPU内部，与当前执行的指令有关 自愿中断（指令中断） 强迫中断 硬件故障（缺页） 软件中断（整数除零） 外中断（中断）信号来源：CPU外部，与当前执行的指令无关 外设请求 人工干预 外中断的处理过程1.每执行完一条指令，CPU都要检查当前是否有外部中断信号 2.如果有，则保存被中断进程的CPU环境 3.转入相应的中断处理程序 4.恢复原进程CPU环境并推出中断，返回原进程继续执行","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"系统调用","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/系统调用/","text":"系统调用什么是系统调用，有什么作用系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为是一种可供应用程序调用的特殊函数，应用程序可以发出系统调用获得操作系统的服务。 凡是与资源有关的操作都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 系统调用和库函数的区别系统调用背后的过程","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"centos7端口开放","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/Linux开放端口/","text":"Linux CentOS 7开放端口12sudo firewall-cmd --zone=public --add-port=6789/tcp --permanentsudo firewall-cmd --reload","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/ytz3210/tags/Linux/"}]},{"title":"mysql忘记密码","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/msql重置密码/","text":"MySQL重置密码1.打开my.cnf文件 12#在[mysqld]的段中加入skip-grant-tables 2.重启mysqld 1service mysqld restart 3.输入 12mysql -u root -p#然后直接敲回车 4.修改密码（5.7之前） 1234use mysqlupdate user set password=password('new password') where user='root'flush privilegesquit 修改密码（5.7之后） 1234use mysqlupdate user set authentication_string=password('新密码') where user='root'flush privilegesquit 5.删除在my.cnf中加入的语句 6.重启mysqld Mysql开启远程登录1234mysql -u root –pmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user; Mysql授权例如，你想root使用123456从任何主机连接到mysql服务器。 1mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 如果你想允许用户jack从ip为10.10.50.127的主机连接到mysql服务器，并使用654321作为密码 12mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;jack&apos;@’10.10.50.127’ IDENTIFIED BY &apos;654321&apos; WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"mysql的卸载和安装","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/卸载MySQL/","text":"Linux CentOS完全卸载MySQL一、yum方式安装，执行以下命令 123yum remove mysql mysql-server mysql-libs compat-mysql57rm -rf /var/lib/mysqlrm -rf /etc/my.cnf 二、判断是否卸载干净 123rpm -qa|grep mysql卸载干净：没有任何输出未卸载干净：继续yum remove xxx","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"Java泛型","date":"2019-11-26T16:00:00.000Z","path":"2019/11/27/Java/Java泛型/","text":"Java泛型什么是泛型？泛型的意思就是广泛的类型，类，接口，方法和变量都可以应用于非常广泛的类型。 泛型怎么用例子： 定义: 12345678910111213141516171819202122232425262728293031323334/** * 单泛型 */public class Study&lt;T&gt;&#123; T student; T teacher; public Study(T student,T teacher)&#123; this.student = student; this.teacher = teacher; &#125; public T getStudent()&#123; return student; &#125; public T getTeacher()&#123; return teacher; &#125;&#125;/** * 多泛型 */public class Teach&lt;U,V&gt;&#123; U student; V teacher; public Teach(U student,V teacher)&#123; this.student = student; this.teacher = teacher; &#125; public U getStudent()&#123; return student; &#125; public V getTeacher()&#123; return teacher; &#125;&#125; 使用 12Study&lt;Integer&gt; study = new Study&lt;&gt;(1,100);Teach&lt;String,Integer&gt; teach = new Teach&lt;&gt;(\"张三\",100); 泛型有哪些好处将接口的概念进一步延伸，使得代码和它们操作的数据类型不再需要绑在一起，一套代码可以适用于多种数据类型，实现更灵活的代码复用，提高代码的可读性和安全性。 1.更好的安全性 2.更好的可读性 与Object相比，Object只有在程序运行时才会提示ClassCastException异常，但是泛型会在编译时就会报错","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/ytz3210/tags/Java/"}]},{"title":"操作系统的概念、功能和目标","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的概念/","text":"操作系统的概念、功能和目标操作系统的概念控制和管理计算机系统的硬件和软件资源，进行计算机的资源的和工作调度，是计算机中最基本的系统软件 操作系统的功能和目标需要提供哪些功能（作为系统资源的管理者）1.文件管理（找到QQ可执行文件的位置） 2.内存管理（QQ运行需要把数据装入内存） 3.处理机管理（QQ运行指令需要处理机调度） 4.设备管理（打开摄像头和朋友视频聊天） 需要实现什么功能（作为用户与计算机硬件之间的接口）1.命令接口：允许用户直接使用 联机命令接口：用户说一句，系统做一句 脱机命令接口：用户说一句，系统做一堆 2.程序接口：允许用户通过程序简介使用 由一组系统调用命令组成，程序接口=系统调用 3.GUI图形用户接口 需要在纯硬件的基础上实现什么功能（作为最接近硬件的层次）对硬件机器进行拓展，组合，使用户无需关心这些东西在底层是怎么组织起来的，让硬件变得更加强大 操作系统的特征并发宏观上在同一时间发生，微观上交替发生 共享 互斥共享 在一个时间段内只允许一个进程访问该资源（视频聊天时，摄像头只允许被一个进程使用） 同时共享 允许一个时间段内由多个进程“同时”（宏观上同时）对它们进行访问（使用不同的软件同时发送同一个文件） 并发性和共享性互为存在条件 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的的意义 如果失去共享性，那么多个程序就不能同时访问系统资源，就无法实现并发访问资源，也就是无法并发 虚拟把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。 例如：一个单核CPU运行六个程序，一个单核CPU是真实存在的，但是用户却感觉好像有六个CPU在同时为自己服务 空分复用技术 时分复用技术 异步多道程序环境下，多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的（有可能遇到阻塞，执行的顺序不一样），而走走停停，以不可预知的速度往前推进。 例如：1，2，3，4总共四个指令 第一种方案：1，2，3，4 第二种方案：1，2（阻塞，等到资源和CPU就位之后才能执行），3，4 第三种方案：4，2，3（遇到阻塞），1 ··· 只有系统拥有并发性，才可能导致异步性","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统的发展与分类","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的发展/","text":"操作系统的发展与分类手工操作阶段-&gt;单道批处理系统-&gt;多道批处理系统-&gt;分时操作系统-&gt; 实时处理系统 操作系统的运行机制和体系结构指令是CPU能识别和执行的最基本的命令 特权指令（不允许用户程序使用） 非特权指令 CPU如何判断当前是否可以执行特权指令？ 答：将CPU分为用户态（目态）和核心态（管态），用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态 ​ 将程序分为内核程序和应用程序，操作系统的内核程序是系统的管理者，既可执行特权指令，也可执行非特权指令，运行在核心态 ​ 应用程序只能执行非特权指令，运行在用户态 内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序 时钟管理 实现计时功能 中断处理 实现中断机制 原语 是一种特殊的程序 位于操作系统最底层，最接近硬件 具有原子性 运行时间短，调用频繁 对系统资源进行管理 进程管理 存储器管理 设备管理 大内核和微内核 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：性能高 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁切换核心态和用户态，性能低","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"秒杀系统基本架构","date":"2019-11-23T14:53:00.000Z","path":"2019/11/23/毕业设计/秒杀系统基本架构/","text":"系统基本架构 基本架构","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"秒杀业务场景分析","date":"2019-11-23T13:47:00.000Z","path":"2019/11/23/毕业设计/秒杀业务场景分析/","text":"秒杀业务场景分析秒杀/抢购业务场景 商品秒杀 商品抢购 群红包 抢优惠券 抽奖 秒杀/抢购业务特点 秒杀商品价格低廉 抢购商品大部分质量很好 大幅推广、广为人知 瞬时售空 定时上架 持续时间短 瞬时并发量高 秒杀/抢购技术特点 读多写少（买得人多，商品数量少）（缓存） 高并发（缓存，限流（重点），负载均衡，异步，队列） 资源冲突（乐观锁，悲观锁，分布式锁，其它原子操作）","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"二叉树的遍历","date":"2019-11-21T09:43:00.000Z","path":"2019/11/21/LeetCode/二叉树遍历/","text":"二叉树的遍历 先序遍历中序遍历后序遍历","tags":[{"name":"递归","slug":"递归","permalink":"https://github.com/ytz3210/tags/%E9%80%92%E5%BD%92/"}]},{"title":"样例","date":"2019-11-20T16:00:00.000Z","path":"2019/11/21/样例/样例/","text":"样例页面 Hello World","tags":[{"name":"样例","slug":"样例","permalink":"https://github.com/ytz3210/tags/%E6%A0%B7%E4%BE%8B/"}]},{"title":"代理模式","date":"2019-11-20T16:00:00.000Z","path":"2019/11/21/设计模式/代理模式/","text":"静态代理模式什么是代理模式首先来看代理模式的三个重要角色 Subject:抽象角色，是一个最普通的业务类型定义，可以是接口，也可以是抽象类 Proxied:具体角色，被代理角色，委托人，被代理者，是业务逻辑的具体执行者 Proxy:代理角色，代理类，在被代理类处理完毕前后做预处理和善后工作 应该怎样理解这三个角色呢？ 比如你要买房，那么买房就是这个抽象角色，而你就是具体角色，也就是被代理角色，因为你买房要找中介，而中介就是代理角色，你只需要执行买房这个动作就行了，而买房前需要干什么，买房后需要干什么都交由中介（代理角色）去完成。 代理可以在保持目标代码对象（Proxied）不动的情况下，对对象访问前后进行一些操作 什么是静态代理模式由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了,事先知道要代理的是什么。 为什么要使用静态代理模式可以在不修改目标对象的前提下扩展目标对象的功能 怎么使用静态代理模式1.创建一个抽象角色 123public interface Subject &#123; void operate();&#125; 2.创建委托人，被代理角色 123456789/** * 实现抽象角色 */public class Proxied implements Subject &#123; @Override public void operate() &#123; System.err.println(\"Proxied实现\"); &#125;&#125; 3.创建代理人 123456789101112131415/** * 实现抽象角色 */public class Proxy implements Subject &#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void operate() &#123; System.err.println(\"Proxy操作前\"); subject.operate(); System.err.println(\"Proxy操作后\"); &#125;&#125; 4.通过客户端创建并访问 12345678public class Client &#123; public static void main(String[] args) &#123; //创建被代理角色 Proxied proxied = new Proxied(); //创建代理角色 Proxy proxy = new Proxy(proxied); proxy.operate(); &#125; 从上述代码可以看出，代理角色和被代理角色都要实现抽象角色这个接口 静态代理模式有什么缺点1.代理角色和抽象角色耦合度高，就是说，如果我有一百个抽象角色，但是每个抽象角色都要使用相同的代理角色的话，必须要创建一百个代理角色，重用性不强 2.一旦接口抽象角色新增方法，目标对象与代理对象都要修改 由此引发了动态代理模式 动态代理模式什么是动态代理模式在程序运行时，运用反射机制动态创建而成，动态代理不知道要代理什么东西，只有在运行时才知道。 为什么要使用动态代理模式当然是为了改进静态代理模式。 怎么使用动态代理模式1.创建一个抽象角色 123public interface Subject &#123; void operate();&#125; 2.创建委托人，被代理角色 123456789/** * 实现抽象角色 */public class Proxied implements Subject &#123; @Override public void operate() &#123; System.err.println(\"Proxied实现\"); &#125;&#125; 3.创建动态代理 123456789101112public class DynamicProxy implements InvocationHandler &#123; private Object target; public DynamicProxy(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.err.println(\"动态代理\"); method.invoke(target,args); return null; &#125;&#125; 4.客户端访问 12345678public class Client &#123; public static void main(String[] args) &#123; Proxied proxied = new Proxied(); InvocationHandler invocationHandler = new DynamicProxy(proxied); Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(Proxied.class.getClassLoader(),Proxied.class.getInterfaces(),invocationHandler); subject.operate(); &#125;&#125; Proxy代理的缺点虽然这种方法降低了对代码的侵入性，可以在不修改源码的情况下增强方法，但是，它是基于接口实现的代理，也就是说被代理人必须要实现一个接口才能被代理，那么有什么方法可以在被代理人不实现接口的情况下实现代理呢？CGLIB代理模式应运而生 CGLIB代理模式什么是CGLIB动态代理CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。 为什么要使用CGLIB动态代理解决Proxy动态代理只能对实现了接口的类生成代理问题 怎么使用CGLIB动态代理1.创建委托人，被代理角色 12345public class CGLIBProxied &#123; public void say()&#123; System.err.println(\"你好，我是CGLIB被代理类\"); &#125;&#125; 3.创建动态代理 12345678910111213141516public class CGLIBProxy implements MethodInterceptor &#123; /** * sub：cglib生成的代理对象 * method：被代理对象方法 * objects：方法入参 * methodProxy: 代理方法 */ @Override public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"======插入前置通知======\"); Object object = methodProxy.invokeSuper(sub, objects); System.out.println(\"======插入后者通知======\"); return object; &#125;&#125; 4.客户端访问 1234567891011121314public class CGLIBClient &#123; public static void main(String[] args) &#123; // 通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); // 设置enhancer对象的父类 enhancer.setSuperclass(CGLIBProxied.class); // 设置enhancer的回调对象 enhancer.setCallback(new CGLIBProxy()); // 创建代理对象 CGLIBProxied proxied= (CGLIBProxied) enhancer.create(); // 通过代理对象调用目标方法 proxied.say(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/ytz3210/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}