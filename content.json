{"pages":[{}],"posts":[{"title":"Redis单机集群配置","date":"2019-12-11T16:00:00.000Z","path":"2019/12/12/redis/单机集群配置/","text":"Redis单机集群配置简介所谓Redis集群就是一个可以在多个Redis节点之间进行数据共享的设施。 因此Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，不仅会降低Redis集群的性能，而且还会导致不可预测的错误。 好处： 将数据自动切分到多个节点的能力 当其中一个节点失效时，仍然可以继续处理命令请求 搭建1.在/usr/local下新建redis-cluster目录并在redis-cluster下新建6380-6385共6个文件夹，这6个文件夹代表创建redis集群的6个节点 12341.cd /usr/local2.mkdir /usr/local/redis-cluster3.cd redis-cluster4.mkdir 6380 6381 6382 6383 6384 6395 2.将已有的/usr/local/redis下的redis.conf拷贝到新创建的6380-6385目录中 修改这6个目录下的redis.conf 1234567891011121314#绑定端口port 6380#指定数据存放路径dir /usr/local/redis-cluster/6380#启动集群模式cluster-enable true#指定集群节点配置文件cluster-config-file nodes-6380.conf#后台启动daemonize yes#指定集群节点超时时间cluster-node-timeout 5000#指定持久化方式appendonly yes 3.将6380的redis.conf改完后再拷贝到剩下的5个目录中，然后只要全局替换redis.conf中的6380为相应的节点即可 4.安装ruby 121.yum install ruby2.yum install rubygems 安装rvm 因为CentOS7 yum库中ruby的版本支持到 2.0.0，可gem 安装redis需要最低是2.2.2，采用rvm来更新ruby 12345678910111.gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB2.curl -sSL https://get.rvm.io | bash -s stable3.find / -name rvm -print4.source /usr/local/rvm/scripts/rvm5.rvm list known6.rvm install 2.4.17.rvm use 2.4.18. rvm use 2.4.1 --default9.rvm remove 2.3.410.ruby --version11.gem install redis 5.启动redis实例 121.cd /usr/local/redis-cluster2.for((i=0;i&lt;=5;i++)); do /usr/local/redis/src/redis-server /usr/local/redis-cluster/638$i/redis.conf; done 6.查看redis是否运行成功 1ps -aux|grep redis 7.创建集群 1redis-cli --cluster create 172.30.0.2:6380 172.30.0.2:6381 172.30.0.2:6382 172.30.0.2:6383 172.30.0.2:6384 172.30.0.2:6385 --cluster-replicas 1 -a &apos;redis密码&apos;","tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/ytz3210/tags/Redis/"}]},{"title":"中断和异常","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/中断和异常/","text":"中断和异常中断机制的诞生为了解决程序只能串行执行，效率低的问题，实现了多道程序并发执行 中断的本质：意味着需要操作系统的介入，开展管理工作 中断的概念和作用1.中断发生时，CPU立即进入核心态 2.中断发生后，当前进程暂停运行，由操作系统对中断进行处理 3.对于不同的中断信号，进行不同的处理 用户态到核心态是通过中断实现的，并且中断时唯一途径 核心态到用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。 中断的分类​内中断（异常）信号来源：CPU内部，与当前执行的指令有关 自愿中断（指令中断） 强迫中断 硬件故障（缺页） 软件中断（整数除零） 外中断（中断）信号来源：CPU外部，与当前执行的指令无关 外设请求 人工干预 外中断的处理过程1.每执行完一条指令，CPU都要检查当前是否有外部中断信号 2.如果有，则保存被中断进程的CPU环境 3.转入相应的中断处理程序 4.恢复原进程CPU环境并推出中断，返回原进程继续执行","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"系统调用","date":"2019-12-01T16:00:00.000Z","path":"2019/12/02/操作系统/系统调用/","text":"系统调用什么是系统调用，有什么作用系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为是一种可供应用程序调用的特殊函数，应用程序可以发出系统调用获得操作系统的服务。 凡是与资源有关的操作都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 系统调用和库函数的区别系统调用背后的过程","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"mysql的卸载和安装","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/msql重置密码的副本/","text":"Linux CentOS完全卸载MySQL一、yum方式安装，执行以下命令 123yum remove mysql mysql-server mysql-libs compat-mysql57rm -rf /var/lib/mysqlrm -rf /etc/my.cnf 二、判断是否卸载干净 123rpm -qa|grep mysql卸载干净：没有任何输出未卸载干净：继续yum remove xxx","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"mysql忘记密码","date":"2019-11-27T16:00:00.000Z","path":"2019/11/28/mysql/msql重置密码/","text":"MySQL重置密码1.打开my.cnf文件 12#在[mysqld]的段中加入skip-grant-tables 2.重启mysqld 1service mysqld restart 3.输入 12mysql -u root -p#然后直接敲回车 4.修改密码（5.7之前） 1234use mysqlupdate user set password=password('new password') where user='root'flush privilegesquit 修改密码（5.7之后） 1234use mysqlupdate user set authentication_string=password('新密码') where user='root'flush privilegesquit 5.删除在my.cnf中加入的语句 6.重启mysqld","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/ytz3210/tags/MySQL/"}]},{"title":"Java泛型","date":"2019-11-26T16:00:00.000Z","path":"2019/11/27/Java/Java泛型/","text":"Java泛型什么是泛型？泛型的意思就是广泛的类型，类，接口，方法和变量都可以应用于非常广泛的类型。 泛型怎么用例子： 定义: 12345678910111213141516171819202122232425262728293031323334/** * 单泛型 */public class Study&lt;T&gt;&#123; T student; T teacher; public Study(T student,T teacher)&#123; this.student = student; this.teacher = teacher; &#125; public T getStudent()&#123; return student; &#125; public T getTeacher()&#123; return teacher; &#125;&#125;/** * 多泛型 */public class Teach&lt;U,V&gt;&#123; U student; V teacher; public Teach(U student,V teacher)&#123; this.student = student; this.teacher = teacher; &#125; public U getStudent()&#123; return student; &#125; public V getTeacher()&#123; return teacher; &#125;&#125; 使用 12Study&lt;Integer&gt; study = new Study&lt;&gt;(1,100);Teach&lt;String,Integer&gt; teach = new Teach&lt;&gt;(\"张三\",100); 泛型有哪些好处将接口的概念进一步延伸，使得代码和它们操作的数据类型不再需要绑在一起，一套代码可以适用于多种数据类型，实现更灵活的代码复用，提高代码的可读性和安全性。 1.更好的安全性 2.更好的可读性 与Object相比，Object只有在程序运行时才会提示ClassCastException异常，但是泛型会在编译时就会报错","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/ytz3210/tags/Java/"}]},{"title":"操作系统的发展与分类","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的发展/","text":"操作系统的发展与分类手工操作阶段-&gt;单道批处理系统-&gt;多道批处理系统-&gt;分时操作系统-&gt; 实时处理系统 操作系统的运行机制和体系结构指令是CPU能识别和执行的最基本的命令 特权指令（不允许用户程序使用） 非特权指令 CPU如何判断当前是否可以执行特权指令？ 答：将CPU分为用户态（目态）和核心态（管态），用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态 ​ 将程序分为内核程序和应用程序，操作系统的内核程序是系统的管理者，既可执行特权指令，也可执行非特权指令，运行在核心态 ​ 应用程序只能执行非特权指令，运行在用户态 内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序 时钟管理 实现计时功能 中断处理 实现中断机制 原语 是一种特殊的程序 位于操作系统最底层，最接近硬件 具有原子性 运行时间短，调用频繁 对系统资源进行管理 进程管理 存储器管理 设备管理 大内核和微内核 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：性能高 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁切换核心态和用户态，性能低","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统的概念、功能和目标","date":"2019-11-25T16:00:00.000Z","path":"2019/11/26/操作系统/操作系统的概念/","text":"操作系统的概念、功能和目标操作系统的概念控制和管理计算机系统的硬件和软件资源，进行计算机的资源的和工作调度，是计算机中最基本的系统软件 操作系统的功能和目标需要提供哪些功能（作为系统资源的管理者）1.文件管理（找到QQ可执行文件的位置） 2.内存管理（QQ运行需要把数据装入内存） 3.处理机管理（QQ运行指令需要处理机调度） 4.设备管理（打开摄像头和朋友视频聊天） 需要实现什么功能（作为用户与计算机硬件之间的接口）1.命令接口：允许用户直接使用 联机命令接口：用户说一句，系统做一句 脱机命令接口：用户说一句，系统做一堆 2.程序接口：允许用户通过程序简介使用 由一组系统调用命令组成，程序接口=系统调用 3.GUI图形用户接口 需要在纯硬件的基础上实现什么功能（作为最接近硬件的层次）对硬件机器进行拓展，组合，使用户无需关心这些东西在底层是怎么组织起来的，让硬件变得更加强大 操作系统的特征并发宏观上在同一时间发生，微观上交替发生 共享 互斥共享 在一个时间段内只允许一个进程访问该资源（视频聊天时，摄像头只允许被一个进程使用） 同时共享 允许一个时间段内由多个进程“同时”（宏观上同时）对它们进行访问（使用不同的软件同时发送同一个文件） 并发性和共享性互为存在条件 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的的意义 如果失去共享性，那么多个程序就不能同时访问系统资源，就无法实现并发访问资源，也就是无法并发 虚拟把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。 例如：一个单核CPU运行六个程序，一个单核CPU是真实存在的，但是用户却感觉好像有六个CPU在同时为自己服务 空分复用技术 时分复用技术 异步多道程序环境下，多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的（有可能遇到阻塞，执行的顺序不一样），而走走停停，以不可预知的速度往前推进。 例如：1，2，3，4总共四个指令 第一种方案：1，2，3，4 第二种方案：1，2（阻塞，等到资源和CPU就位之后才能执行），3，4 第三种方案：4，2，3（遇到阻塞），1 ··· 只有系统拥有并发性，才可能导致异步性","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://github.com/ytz3210/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"秒杀系统基本架构","date":"2019-11-23T14:53:00.000Z","path":"2019/11/23/毕业设计/秒杀系统基本架构/","text":"系统基本架构 基本架构","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"秒杀业务场景分析","date":"2019-11-23T13:47:00.000Z","path":"2019/11/23/毕业设计/秒杀业务场景分析/","text":"秒杀业务场景分析秒杀/抢购业务场景 商品秒杀 商品抢购 群红包 抢优惠券 抽奖 秒杀/抢购业务特点 秒杀商品价格低廉 抢购商品大部分质量很好 大幅推广、广为人知 瞬时售空 定时上架 持续时间短 瞬时并发量高 秒杀/抢购技术特点 读多写少（买得人多，商品数量少）（缓存） 高并发（缓存，限流（重点），负载均衡，异步，队列） 资源冲突（乐观锁，悲观锁，分布式锁，其它原子操作）","tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"https://github.com/ytz3210/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}]},{"title":"二叉树的遍历","date":"2019-11-21T09:43:00.000Z","path":"2019/11/21/LeetCode/二叉树遍历/","text":"二叉树的遍历 先序遍历中序遍历后序遍历","tags":[{"name":"递归","slug":"递归","permalink":"https://github.com/ytz3210/tags/%E9%80%92%E5%BD%92/"}]},{"title":"样例","date":"2019-11-20T16:00:00.000Z","path":"2019/11/21/样例/样例/","text":"样例页面 Hello World","tags":[{"name":"样例","slug":"样例","permalink":"https://github.com/ytz3210/tags/%E6%A0%B7%E4%BE%8B/"}]}]}